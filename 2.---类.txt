//枚举
            /*
			 * 格式：enum 枚举名{枚举值1,枚举值2,枚举值......}
                          枚举值不能为整数或小数  
			 * 创建枚举变量格式：枚举类型 变量名=枚举类型.枚举值
			 * 枚举值默认跟整型数字进行关联，从0开始，不同的成员可以有相同的常量值；
			 * 还可以给枚举值关联指定数字,后面的枚举值依次累加
			 *  枚举类型.枚举值.GetHashCode() :获取枚举值对应的哈希值；枚举值关联的整型值
			 * 枚举类型.枚举值.GetTypeCode():获取关联的数值类型
			 *  枚举类型.枚举值.GetType():获取到该变量所属的枚举类型
			 */
//类
    /*类：具有相同特征和行为的抽象
	 * 类的定义使用关键字class
	 * class 类名{},如果不写修饰符public，默认是internal
	 * 类是泛指，对象是特指(具体的)
	 * 类的成员变量构成
	 * 1.字段用来描述类的特征
	 * 2.方法是用来描述类的行为
	 * 3.属性用来给类中私有的字段初始化
	 * 方法的格式：修饰符  返回值类型 方法名 （参数列表）{
	 * 方法体}(有返回值需要return;就是根据方法的返回值类型来返回相应的值)
	 * 根据返回值类型和参数列表可以分为4种：
	 * 1.无参数无返回值
	 * 格式：修饰符 void 方法名(){
	 * 方法体}  调用方法：先实例化一个对象a,通过a.方法名();来访问
	 * 2.无参数有返回值
	 * 格式：修饰符 返回值类型 方法名(){
	 * 方法体
	 * return 值;(当方法有返回值的时候，需要用到关键字return，且一个方法只能有一个返回值)
	 * }
	 * 调用的格式：类型 变量=实例变量.方法名();
	 * 3.有参数无返回值
	 * 修饰符 void 方法名(参数类型1 参数名1,参数类型2 参数名2......){
	 * 方法体} 
	 * 调用方法：先实例化一个对象a,通过a.方法名();来访问
	 * 4.有参数有返回值
	 * 格式：修饰符 返回值类型 方法名(参数类型1 参数名1,参数类型2 参数名2......){
	 * 方法体
	 * return
	 * }
	 * 调用的格式：类型 变量=实例变量.方法名(参数类型1 参数名1,参数类型2 参数名2......);
	 * 修饰符是public，protected，private（默认）
	 * 
     ！！！！！注意：当方法有返回值的时候，需要用到关键字return，且一个方法只能有一个返回值
                     实参的类型可以是形参的子类型（如 object 与string），实参的数目必须要和形参相同
                      （特别说明：有些形参中包含了params，但是实参中的元素只是相当于一个数组）







	 * 眼镜：(类)
	 * 老司机身上带的眼镜（对象）
	 * 对象的创建,使用new 关键字
	 * 格式：类名 变量名=new 类名();
     */

// 面向过程      面向对象
//OOP是面向对象的英文缩写（Object Oriented Programming）
      //下载两张图片，拼接在一起，打上水印
             /*1.
			 * 面向过程：步骤环节
			 * 下载两张图片
			 * 拼接
			 * 打上水印
			 * 发布
			 */


         /*2.
               面向对象
               叫美工
            */                        
   

//属性
      /*属性提供了设置器，访问器
	     格式： 
	     修饰符 类型 变量名{
         //set方法
        set {
			
		}
		  //get方法
		get{
			return 变量名
		}
	  }
	  1.当实例对象.属性      是一个赋值操作的时候就会调用属性的set方法
        2.当实例对象.属性   是一个访问操作的时候就会调用属性的get方法
	*/
//属性的第一种用法：默认实现，当属性访问器中不需要其他访问逻辑时候，就可以使用自动属性，使代码更加简洁
         //public string Name{ set;get;}基本上用不到
//属性的第二种用法：给字段添加set和get
        //private float weight;
//一般来说,属性的名称与字段的名称（首字母大写）
		private float weight;
		public float Weight{ 
	       set{
		//value是系统默认传进来的值
		Console.WriteLine("设置了值");
		if(value >0){
			weight=value;

		}
		else
			Console.WriteLine ("你是不是傻啊");
	    }
	      get{
		  Console.WriteLine("访问了Weight的get方法");
		  return weight;
	      }
        }
//给属性增加权限
		    /*
			 * (可读可写，只可读，只可写)
			 * readAndWrite
			 * readOnly
			 * writeOnly
			*/
		public string gender{
			//只读
			get{ 
				return  "male";}
		}
		public string ID {
			//只写
			set{ }
		}
//构造方法(一般是public，这样才能在其他类中创建该类的对象并初始化，也可以是private，比如单例)
       /*1.构造方法：当我们创建实例对象的时候使用类名+(),就是调用了该类的默认构造方法
	 * 2.默认构造方法格式：类名(){}  
	 * 3.当我们创建类的时候系统会自动给我们一个该类的默认构造方法
	 * 注意：1).方法名跟类名相同
	 * 2).不用写返回值的类型
	 * 3).不用return
	 * 构造方法主要是创建对象进行初始化
	 * 当我们给系统添加了自定义的构造方法之后想要使用系统默认的构造方法必须手动提供
	 
	 * 3.重载：在同一个类里面存在两个或两个以上方法名相同但是参数列表（类型不同或个数不同）不同叫做方法重载
	 * 优点：提高方法扩展性
	 * 重载跟返回值类型无关！！！
	 * 
      */

//this的用法	
		/*this关键字；
		* 1）this关键字用来区分局部变量和成员变量同名的情况
		* this.成员变量   会访问到该类的成员变量
		* 2）this在方法里面表示(调用该方法所在的类的实例对象)的引用
		* 比如我声明了一个实例对象,this就表示对他的引用,即代表这个对象
		*/
//面向对象的特性（封装，继承，多态）
		/*面向对象的特性（封装，继承，多态）
		* 封装：将特定的功能代码使用方法存储起来，并提供对外访问的接口
		* 好处：
		* 1.提高代码的复用性，好处是当需要修改技术细节的时候，可以不影响调用者与类的交互方式，保证数据完整性。
		* 2.方便代码的阅读，对问题的定位更加方便
		*/
//继承
		//当类之间存在共性，继承关系的时候就使用继承
                 继承可以方便的重用已有的代码和数据
		/*格式： A类继承B类     class A:B
	      * 被继承的类叫做基类（父类），继承了基类的类叫做派生类（子类）
	      * 派生类继承了基类的所有公共的成员变量（字段和方法，属性）
	       * 类的继承只能单继承，也就是说子类只能有一个父类
	       */
//重写
		/*虚方法：重写
		* 基类里面有些方法需要在派生类里面重新写的就将基类的方法使用virtual修饰(放在返回值类型的前面)，就称为虚方法
                * 虚方法与抽象方法的区别是：在类中虚方法声明之后必须实现，而抽象方法只声明不实现
		* 派生类重写该方法使用override 关键字修饰
		* 派生类重写了之后派生类调用的是重写后的方法，基类调用的是原来的方法
		* 部分重写:  通过base关键字来调用基类的方法
		*/
//隐藏方法(覆盖)
		/*隐藏方法(覆盖)：
		* 基类跟派生存在签名相同的方法，并且基类和派生类中的方法没有直接用virtual和override修饰，那么就是隐藏方法
		* 派生类的隐藏方法用new(放在返回值类型前面)关键字修饰
		*/

//覆盖跟重写的区别：
		/*覆盖跟重写的区别：
		* 重写之后基类的方法不存在了，就是功能已经被改变了，所以当父类指针指向子类对象的时候，调用的是重写之后的方法
		* 覆盖（隐藏方法）之后基类还存在，所以当父类指针指向子类对象的时候，调用的是父类的方法
		*/

//派生类构造方法调用基类无参数构造方法
		/*1.调用基类无参数的构造方法可以不显示调用
		 * 派生类在生成实例对象的时候会自动调用基类的默认构造
		 * 2.只要是派生类的构造方法都会去自动调用基类的默认构造,如果基类中不写默认构造，会出错

！！！！！！！注意：如果派生类中的默认构造里有字段初始化赋值，系统会先调用父类的默认构造然后在赋值


		*/
//自定义的构造方法：调用基类有参数的构造方法(显示调用：用base)
		/*public Student ( string name,int  age, string address,string gender,int ID,string schoolName):base(name,age,address,gender)
		{
			this.ID=ID;
			this.schoolName=schoolName;
		}
       */

//堆栈
		/*堆栈
		栈区内存空间小，读取速度快，堆区内存空间大，读取速度慢
		栈的特点：先进后出
		入栈：将数据压入栈顶    出栈：将栈顶的数据弹出栈称为出栈
		存放在栈中的数据：整数，小数，bool，char，结构体
		存放在堆中的数据：string，数组，自定义的类，内置类

  !!!!!!!注意：1.string a="dsasa";  a存在于栈，指向堆区中的常量区的值"dsasa"
               2.string b=null; string b1=""; b表示没分配内存为空，b1分配了内存，但是是一个空的引用
               引用类型的数据都是通过new来分配内存空间的（string 是隐式分配的）
                而 值类型是 系统自动分配内存空间的 
		c#数据分为两种：值类型，引用类型
		1.值类型只需要一段内存存储，在栈中开辟内存空间存储，值类型的参数是对栈中数值进行拷贝（int a=1;int b=a;）
		2.引用类型需要两端内存存贮，一段在堆中开辟内存空间存储实际数据，另一段在栈中存储实际数据在堆中的地址
                    而引用类型只是在栈区复制他的地址；
		若数组里面是值类型，则在堆里面直接存储，若数组里面是引用类型，则在堆里面存储它的引用
		*/  

	
//结构体

		/*结构体：自定义的一种数据类型，可以存放多种数据类型
		格式：
		struct 结构体类型名{
			结构体成员变量（包括字段，属性和方法）
		}
	
		注意：必须在类的外面定义结构体，这样的话，此类与其他类都可以使用

		
	  * 结构体的字段在结构体中只能定义，不能赋值
	  * 结构体的构造方法跟类的格式一样：
	  *1) 默认构造（无参）结构体的默认构造不能写，因为已经提供(与类不同)
	  * 2)在结构体的自定义构造方法中必须给所有的字段（也就是说必须声明所有的字段且进行赋值）进行赋值，而类中可以不用声明所有，赋值
	  * 3）结构体自定义构造方法后，外界都访问的到默认的
	  * 注意：在类中，自定义构造方法后，如果没有显示写出默认构造，外界不能访问的到默认的
	 
	  * 
           有两种情况：public  struct  Person
            1.结构体中 没有私有字段
              调用时可以只声明：Person p；
              此时你可以访问字段，然后你必须给所有字段赋初值，才能调用结构体的非静态方法。
             2. 结构体中 有私有字段
               如果你只声明 ：Person p；
              那么你只可以访问公有的字段，因为结构体变量访问属性一定要先通过new关键字创建初始化(与类相似)
  ！！！！注意：结构体有默认构造，当你声明一个对象并初始化(Person p=new Person(); )之后，
                可以调用其中的公有字段，属性，非静态方法 ,
                





             
	 
	  * 在结构体构造方法里面不允许通过属性给私有字段赋值
	  * 例如：public  Person(int age,string  name  ){
			this.age = age;
			this.name = name;
		} 可以实现
           （Age是私有字段age的属性）

        public  Person(int age,string  name  ){
			this.Age = age;
			this.name = name;
		}不能实现

		结构体跟类的区别：
	
		 * 1.写法区别 ，结构体struct，类class
                 * 2.结构体不能被继承，类可以被继承
                 * 3.结构体和类一样包括字段，属性和方法，但是结构体的字段在结构体中只能定义，不能赋值
                 * 4.结构体没有析构函数
                 * 5.结构体的默认构造不能写，因为已经提供(与类不同)
                 * 6.在结构体的自定义构造方法中必须给所有的字段进行赋值，且不允许通过属性给私有字段赋值
		 * 7.结构体是值类型，存储于栈区   类是引用类型，存储于堆区
		

//四大修饰符
		/*public:公共的，访问不受限制
		 * private:该修饰符所修饰的成员只能在类或结构体的内部使用
		 * 在派生类和外部都不可以访问的到
		 * protected:该修饰符修饰成员只能在类及其子类的内部可以访问
		 * internal仅限于当前程序集可访问的到
	!!!!!!	 * 类只有两种修饰符public  internal 默认是internal
		 * 类成员默认修饰符是private ,internal 可以用来修饰成员，还可以与protected连用（internal  protected）
		*/
//参数的转换
		//值类型作为实际参数进行运算不会改变本身的值(不加ref统一"认为"是值类型)也就是说如果是string类型的数据不加ref，同样无法交换值
		//例如  int num1，int num2
		/*因为num1与num2是值类型，会直接将值拷贝一份给形参，交换的只是形参的值
		   1.如果加上了ref 会将num1与num2的内存地址赋予value1与value2，方法的定义和调用都需要使用关键字ref！！！形式：ref  变量类型  形参名  调用 ：ref  实参名
		    2.使用ref关键字修饰的变量必须先初始化
		 */

//输出参数
		/*out
		 * 1.输出和调用都需要使用关键字out！！！
		 * 2.使用out关键字修饰的变量可以不用先初始化
		*/

		//一个方法同时计算两个数的加减
		public  static void  Calculate(int value1,int value2,out int sum,out int difference){
			sum = value1 + value2;
			difference = value1 - value2;
		}

		//使用params修饰的数组，在调用方法的时候可以不写数组名,如果有多个变量，则params修饰的变量放在最后
		//定义一个方法给整形数组中的元素做累加运算
		public static void getSum(params int []a){
			int sum = 0;
			for (int i = 0; i < a.Length; i++) {
				sum = sum + a [i];
			}
			Console.WriteLine (sum);
		}
		//调用：类名.getSum(1,2,34,5,4)
		public  static void swap(  ref int  value1,ref int value2){
			int temp = value1;
			value1 = value2;
			value2 = temp;
		}

//析构方法，用来释放全局变量等	
		/*析构方法：在对象销毁回收内存的时候调用的
	  *格式：~类名(){
	  *   }
	  * 析构没有返回值，也没有参数列表，不能重载，没有访问修饰符，不能主动调用，垃圾回收机制会自动调用
	  * 析构方法只能定义在类里面，一个类里面只能有一个析构方法
	  * 析构销毁的顺序：最后创建的对象先销毁（与创建对象的顺序有关），子类先销毁（子类先调用本身的析构方法，再调用基类的）！！！
	 */





		//匿名类型:(var)根据赋的初值（必须要有初值）自动推导变量的实际类型，变量类型一经确定就不允许改变
		//例如  double a=2.3; 可以写成 var a=2.3 且变量类型一经确定，不可改变。
		/*密封：C#允许使用sealed关键字来修饰类与方法，当修饰类的时候表示该类不允许被继承且不允许被其他类访问
       *  当修饰方法的时候，该方法不能被重写
       * 只能将一个重写的方法进行密封，密封之后的方法不可以被重写，但是可以被覆盖
      */


//里氏转换
		/*当父类指针指向子类实例对象的时候
		* 调用虚方法执行的是派生类的里面重写之后的方法
		* 调用隐藏方法执行的是基类的里面的方法
		* 重写（Override）的两个函数的函数特征相同，应用在子类和父类中，会重写父类函数；
		* 重载（Overload）的两个函数的函数名虽然相同，但函数特征不同，应用在同一类中；
		* 覆盖（new）两个函数的函数名一定相同，但函数特征可相同也可不相同，应用在子类和父类中，会隐藏父类同名函数

		





		       /*as 关键字：将父类指针转向实际类型  Sparrow s01=b0  as Sparrow; 子类名  变量1=之前声明的变量 as 子类名
			        * 当父类指针转向实际类型的时候，不管是调用虚方法，还是调用隐藏方法
			        * 最终执行的都是派生类的方法
                  */








//多态：同一个操作，作用不同的对象有不同的实现
		//is 用来判断一个对象是否是指定的对象
//抽象方法	
	    	/*当基类当中某些方法一直不会被调用就可以考虑将该方法声明为抽象方法
          抽象方法用关键字abstract修饰用abstract修饰的方法只能有声明不能有实现
            
          抽象方法所在的类必须为抽象类，同样用关键字abstract修饰
           抽象类不能被实例化，只能被继承，抽象类中可以有静态成员（静态方法只能使用类中的静态字段或常量）而其他的字段，方法
           只能声明不能调用，因为抽象类不能被实例化 
        抽象类里面可以没有抽象方法，抽象类当中一样可以有普通方法
        当只有一个非抽象类继承抽象类的时候，必须实现其中的所有抽象方法，否则编译不通过
         原因：一个而抽象方法没有被实现外界去访问会存在错误
         抽象方法一样支持方法重载，只能被重写，不能被隐藏
        抽象类可以继承抽象类，继承之后可以选择实现当中的抽象方法；
        抽象类B继承了抽象类A，当抽象类B部分实现抽象类A此时普通类C继承抽象类B，可以只实现抽象类B没有实现的抽象方法；
          */


      
    
   
//静态
		/*1.静态：
              *在不需要使用对象来做其他事情,变量需要被共享的时候，方法需要被反复调用的时候，就可以把这些成员定义为静态成员
              *静态方法：使用static关键字进行修饰
              *普通实例方法通过对象来调用，静态方法通过类来调用
              *静态成员随着类的加载而加载
              *只要是静态成员都是使用static 修饰
              *2.共享数据 
              *非静态成员跟静态成员：
              *1）非静态成员由类的实例对象来调用，静态成员由类来调用,类加载的时候，所有的静态成员就会被创建在“静态存储区”里面，一旦创建直到程序退出，才会被回收
              *2）静态成员随着类的加载而加载，非静态随着对象的创建而存在,静态成员只被创建一次，所以静态成员只有一份，实例成员有多少个对象，就有多少份
              *3）静态成员与非静态成员之间的调用： 非静态可以调用静态成员变量，静态不能调用非静态的成员变量，它
              *只能访问静态成员
              *3.静态类：有static个关键字进行修饰，不能被实例化,内部只允许有静态成员或const 修饰的常量
              *静态类的本质，是一个抽象的密封类，所以不能被继承，也不能被实例化
              *形式：const  变量类型   变量名A=值        一经定义，A的值就确定了，不可改变
              *4.静态构造：
              *格式：static 类名（）{}  没有参数,没有返回值，除了static不能有其他修饰符
              *可以存在于所有类当中
              *静态构造在类加载进内存的时候(第一次使用的时候)进行调用，一般用来给静态成员变量赋值
              *这个类的成员第一次被访问之前，就会执行静态构造函数 ,静态构造函数只被执行一次。
               class Program
    {
        public static int i =0;
        public Program()
        {
            i = 1;
            Console.Write("实例构造方法被调用");
        }
        static Program()
        {
            i = 2;
            Console.Write("静态构造函数被执行");
        }
        static void Main(string[] args)
        {
            Console.Write(Program.i);//结果为2，首先，类被加载，所有的静态成员被创建在静态存储区，i=0,接着调用了类的成员，这时候静态构造函数就会被调用，i=2
            Program p = new Program();
            Console.Write(Program.i);//结果为1，实力化后，调用了实例构造函数，i=1，因为静态构造函数只执行一次，所以不会再执行。
        }
    }
              */

//设计模式：前人留下来的一些程序设计经验
		/*
		 * 单例设计模式：一个类只有一个实例对象，不管你怎么通过new去创建，始终都是同一个对象
		 */

		//单例类

		/*public class SingleDog
		{

			public string type;
			//默认构造私有化 
			1.private SingleDog ()
			{
			}
			//内建静态实例
			2.static SingleDog instance = new SingleDog();
            第 2步可以只定义一个 类  SingleDog类型 的 变量，然后在第3步的静态构造方法中进行初始化
			//在静态构造方法里面初始化
			3.static SingleDog(){
				//			instance = new SingleDog ();
			}

			// 单例命名规范Share+类名
			4.public static SingleDog ShareSingleDog(){
                                if(instance==null){  
				instance = new SingleDog ();
			}
                      return instance;
}

		}
     */
		/*public class SingleDog
		{

			public string type;
			//默认构造私有化 
			1.private SingleDog ()
			{
			}
			//内建静态实例
			2. private static SingleDog instance;

			

			 // 静态实例初始化
			3.public static SingleDog  Instance{
				get{if(instance==null){
						instance=new SingleDog();}
					return instance;
				}
			}
		  

		*/
//接口
		/*接口：当我们在程序设计的时候，基类当中的所有方法都不调用的时候
		使用接口来代替类，提高延展性
		格式：public interface  接口名{
			方法的声明 
			1.不能写修饰符，默认就是public的
		}
		接口只能被实现（写法跟继承一样），不能实例化
		当类实现接口的时候必须将类当中的所有方法实现,并且其中实现接口的方法一定是public的
		因为接口中的方法是public类型的
		
                接口可以多实现，在一定程度上弥补了类不能多继承的缺陷，实现多个接口，接口之间使用逗号隔开
		接口中不能包含字段！！！！！
		
                如果一个类A已经实现了接口，那么他的派生类B可以不用实现方法，调用的时候会调用基类A的方法
		抽象类一样可以实现接口，当接口中的方法在抽象类中不是抽象方法的时候就必须实现
		是抽象方法的时候就可以不实现，让抽象类的派生类来实现
		
            接口之间也可以实现例如：接口A继承了接口B，类C实现了A，则C必须将A和B的所有方法都实现
       注意 ：接口跟抽象类实现的区别：一个类去实现抽象类需要写关键字override，而去实现接口则不需要写
		*/
	
//泛型：能够将类型作为参数来传递

	/*优点：使用泛型类型可以最大限度地重用代码，保护类型的安全以及提高性能
	 * 降低了强制转换或装箱操作的成本或风险
	 * 可以对泛型类进行约束以访问特定数据类型的方法
	 * 
	 * 以前是通过方法的重载来实现不同参数类型的运算
	 * 泛型的方法：当方法中参数类型不确定的时候，使用泛型，T只是一个默认代号，也可以用其他大写字母
	 * 修饰符 返回值类型  方法名<T>(参数列表){
	 * }
	 * 泛型方法调用：方法名<泛型的具体类型>(实参)
	 * 注意：泛型的具体类型可以不指明，但是一定要跟实参的类型对应
	 * 
	 * 泛型类：类里面有一些不确定类型的成员变量的时候使用；
	 * 格式： class 类名 <泛型>
	 * 实例化：类名 <具体类型> 对象名=new 类名<具体类型>();
	 * 
	 * 运算符：> < +  -不能应用于泛型
	 * 
	 * 泛型类型的限定：使用where  关键字
	 * 1. where T :struct ：表示泛型T是值类型(小数，整数，char,bool,struct)
	 * 2. where T :class ：表示泛型T是引用类型
	 * 3.where T :new ()  :表示泛型T(此时T是一个类的类型)具有一个无参数的默认构造,如果有多个限制，new()必须放在最后，中间用逗号隔开
	 * 4.where T ：类名A   表示泛型T是该类的本类A或派生类B的类型
	 * (如果通过T声明了一个B类型的对象，其实是A类型的指针指向B类型的对象，一定要注意多态性，也就是想调用B类里面的（new）覆盖方法只会调用父类A里面的方法 )
	 * 5.where T ：接口名A   表示泛型是接口的类型或者是实现了接口的类的类型
	 *   
	 * 多个泛型的泛型限定,如:public class Farm<T,M>where  T:Dog,new () where M:class
	*/
	
